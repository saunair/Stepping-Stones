#include <ros/ros.h>
#include <std_msgs/Float32.h>
#include <tf/transform_broadcaster.h>
#include <nav_msgs/Odometry.h>
#include <geometry_msgs/Twist.h>
#include <cmath> // M_PI
#include <sensor_msgs/Imu.h>
/** 
 *  @brief Class to manage robot state publishing
 *
 *  Style: Class names are all UpperCased
 */
class RobotTransformManager
{
public:

	sensor_msgs::Imu robot_odometry_; 
	ros::NodeHandle n_;
  	ros::Subscriber odom_sub_; ///< members are suffixed with '_'
  	tf::TransformBroadcaster tf_broadcaster_;

	RobotTransformManager()
	{
	//	odom_sub_ = n_.subscribe("/odom_abs", 0, &RobotTransformManager::updateRobot, this);
		
		odom_sub_ = n_.subscribe("/imu/data", 1000, &RobotTransformManager::updateRobot, this);
	}

private:
	/** 
	 *  @brief Callback for odometry message to update the transform of the robot
	 *
	 *  Style: All class methods should be camelCased
	 */
	void updateRobot(const sensor_msgs::Imu& msg)
	{
		// Hint: at a terminal use: 
		//      $ rosmsg show nav_msgs/Odometry 
		//
		// to display information about message
	        robot_odometry_ = msg;
	    

	    //Create the transform message and stuff it with data
	    // Hint: at a terminal use: 
            // $ rosmsg show geometry_msgs/TransformStamped
	    geometry_msgs::TransformStamped base_link_tf;
	    base_link_tf.header.stamp = ros::Time::now();
	    base_link_tf.header.frame_id = "world";
	    base_link_tf.child_frame_id = "base_link";
		
	    //ros::param::get("/odom", odom);

	    // Now to copy the translation part of the message
	    // TODO

	  //  base_link_tf.transform.translation.x = msg.pose.pose.position.x;
	  //  base_link_tf.transform.translation.y = msg.pose.pose.position.y;
	  //  base_link_tf.transform.translation.z = msg.pose.pose.position.z;


	    base_link_tf.transform.rotation.x = msg.orientation.x;
	    base_link_tf.transform.rotation.y = msg.orientation.y;
	    base_link_tf.transform.rotation.z = msg.orientation.z;




	//    base_link_tf.transform.rotation.x = msg.pose.pose.orientation.x;
	 //   base_link_tf.transform.rotation.y = msg.pose.pose.orientation.y;
	  //  base_link_tf.transform.rotation.z = msg.pose.pose.orientation.z;


	    // Now send the message over the TF server
	    tf_broadcaster_.sendTransform(base_link_tf);
		
	}
};

int main(int argc, char** argv){
  ros::init(argc, argv, "robot_transform_node");
  RobotTransformManager robotManger;
  
  ros::spin();
  return 0;
}
